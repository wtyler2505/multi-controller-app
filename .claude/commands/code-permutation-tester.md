---
model: claude-sonnet-4-20250514
category: utilities-tools
priority: high
tags: ["utilities-tools", "testing"]
description: Code Permutation Tester

# Enhanced Context-Aware Agent Integration
enhanced-integration:
  enabled: true
  agent-selection-criteria:
    domain-expertise: ["code-analysis", "testing-strategies", "algorithmic-comparison"]
    complexity-factors: ["permutation-testing", "performance-analysis", "comparative-evaluation"]
    specialized-tools: ["code-testing", "performance-measurement", "comparative-analysis"]
  preferred-agents:
    primary: "mock-test-orchestrator"
    secondary: "general-purpose"
    fallback: ["task-orchestrator"]
  tool-requirements:
    mcp-servers: ["clear-thought", "desktop-commander", "cipher-memory"]
    specialized-functions: ["code-testing", "performance-analysis"]

# Universal Cipher Memory Integration (MANDATORY FOR ALL COMMANDS)
cipher-memory-integration:
  enabled: true
  priority: "high"
  
  # Pre-execution Memory Operations
  pre-execution-memory:
    context-search:
      - query-pattern: "code-permutation-testing + algorithmic-comparison + performance-analysis"
      - tools: ["mcp__cipher-memory__search_nodes", "mcp__cipher-memory__open_nodes"]
      - context-retrieval: "testing-patterns + comparative-analysis-techniques"
    
    knowledge-preparation:
      - domain: "code-testing"
      - pattern-search: "permutation-testing + algorithm-comparison + performance-evaluation"
      - tools: ["mcp__cipher-memory__read_graph"]
  
  # Execution Memory Operations
  execution-memory:
    progress-tracking:
      - tool: "mcp__cipher-memory__add_observations"
      - capture-points: ["permutation-generation", "test-execution", "performance-analysis"]
      - entity-updates: "real-time-progress"
    
    decision-logging:
      - tool: "mcp__cipher-memory__create_entities"
      - log-decisions: "testing-strategies + comparison-methods + evaluation-criteria"
      - pattern-recognition: "permutation-testing-patterns"
  
  # Post-execution Memory Operations
  post-execution-memory:
    result-storage:
      - tools: ["mcp__cipher-memory__create_entities"]
      - store-patterns: ["permutation-test-results", "performance-comparisons", "algorithmic-insights"]
      - knowledge-extraction: "testing-methodologies + comparative-analysis-techniques"
    
    relationship-creation:
      - tools: ["mcp__cipher-memory__create_relations"]
      - link-concepts: ["algorithm-relationships", "performance-correlations", "testing-dependencies"]
      - cross-reference: "related-testing-strategies"
    
    knowledge-refinement:
      - tools: ["mcp__cipher-memory__add_observations"]
      - enrich-existing: "testing-knowledge + algorithmic-patterns"
      - continuous-learning: "testing-strategy-optimization"

# Centralized Logging Integration
logging-integration:
  enabled: true
  log-file: ".claude/command-execution.jsonl"
  
  # Comprehensive Execution Logging
  log-level: "comprehensive"
  
  capture-points:
    - command-initiation
    - agent-selection-process
    - memory-operations
    - permutation-generation
    - test-execution
    - performance-measurement
    - comparative-analysis
    - error-handling
    - completion-status
  
  # Structured Log Format
  log-structure:
    timestamp: "ISO-8601"
    command: "code-permutation-tester"
    execution-id: "UUID"
    agent-assignments: "selected-agents-with-reasoning"
    memory-operations: "cipher-memory-transactions"
    performance-metrics: "execution-time + memory-usage + success-rate"
    outcome-summary: "permutation-test-results + performance-insights"

# Cross-Command Learning Integration
cross-command-learning:
  enabled: true
  share-insights: ["testing-patterns", "performance-analysis-techniques", "comparative-methodologies"]
  learn-from: ["generate-tests", "test-coverage", "setup-comprehensive-testing"]
  contribute-to: "testing-strategy-knowledge-base"

# Workflow Integration
workflow-integration:
  pre-execution:
    - validate-testing-environment
    - prepare-memory-context
    - select-optimal-agents
  
  execution:
    - parallel-permutation-testing
    - continuous-memory-updates
    - real-time-performance-tracking
  
  post-execution:
    - comprehensive-result-storage
    - cross-reference-generation
    - testing-pattern-extraction
---

|
| Approach A | 85% | 70% | 90% | 75% | 80% |
| Approach B | 70% | 90% | 80% | 85% | 81% |
| Approach C | 95% | 60% | 70% | 65% | 73% |

### Detailed Analysis

#### Recommended Approach: [Selected Variation]

**Rationale:**
- Performance Advantages: [specific benefits and measurements]
- Maintainability Considerations: [long-term support implications]
- Risk Assessment: [identified risks and mitigation strategies]
- Business Alignment: [strategic fit and market timing]

**Implementation Plan:**
- Development Phases: [staged implementation approach]
- Quality Checkpoints: [validation gates and success criteria]
- Risk Mitigation: [specific risk reduction strategies]
- Performance Validation: [ongoing monitoring and optimization]

#### Alternative Considerations:
- Backup Option: [second-choice approach and trigger conditions]
- Hybrid Opportunities: [combining best elements from multiple approaches]
- Future Evolution: [how to migrate or improve chosen approach]
- Context Dependencies: [when alternative approaches might be better]

### Success Metrics and Monitoring
- Performance KPIs: [specific metrics and acceptable ranges]
- Quality Indicators: [maintainability and reliability measures]
- Business Outcomes: [user satisfaction and business impact metrics]
- Early Warning Signs: [indicators that approach is not working]
```

### 8. Continuous Learning Integration

**Establish feedback loops for approach refinement:**

#### Implementation Validation
- Real-world performance comparison to simulation predictions
- Developer experience and productivity measurement
- User feedback and satisfaction assessment
- Business outcome tracking and success evaluation

#### Knowledge Capture
- Decision rationale documentation and lessons learned
- Best practice identification and pattern library development
- Anti-pattern recognition and avoidance strategies
- Team capability building and expertise development

## Usage Examples

```bash
# Algorithm optimization testing
/dev:code-permutation-tester Test 5 different sorting algorithms for large dataset processing with memory and speed constraints

# Architecture pattern evaluation
/dev:code-permutation-tester Compare microservices vs monolith vs modular monolith for payment processing system

# Framework selection simulation
/dev:code-permutation-tester Evaluate React vs Vue vs Angular for customer dashboard with performance and maintainability focus

# Database optimization testing
/dev:code-permutation-tester Test NoSQL vs relational vs hybrid database approaches for user analytics platform
```

## Quality Indicators

- **Green**: Multiple variations tested, comprehensive quality gates, validated performance predictions
- **Yellow**: Some variations tested, basic quality assessment, estimated performance  
- **Red**: Single approach, minimal testing, unvalidated assumptions

## Common Pitfalls to Avoid

- Premature optimization: Over-engineering for theoretical rather than real requirements
- Analysis paralysis: Testing too many variations without making decisions
- Context ignorance: Not considering real-world constraints and team capabilities
- Quality tunnel vision: Optimizing for single dimension while ignoring others
- Simulation disconnect: Testing scenarios that don't match production reality
- Decision delay: Not acting on simulation results in timely manner

Transform code implementation from guesswork into systematic, evidence-based decision making through comprehensive variation testing and simulation.


