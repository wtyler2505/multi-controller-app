# Task ID: 3
# Title: Prototype UI with Serial Echo (C# Native AOT and Rust)
# Status: done
# Dependencies: 1
# Priority: high
# Description: Develop minimal UIs in both C# (.NET 8 Native AOT) and Rust to test serial communication and measure resource usage.
# Details:
Implement a single-window UI in both C# (WinUI 3, Native AOT) and Rust (egui or native Win32 bindings). Integrate basic serial port echo functionality using System.IO.Ports (C#) and serialport-rs (Rust). Measure RAM, CPU, and cold-start times using Windows Performance Monitor.

# Test Strategy:
Run both prototypes on Windows 11. Measure startup time, idle CPU, and RAM usage. Validate serial echo functionality with a loopback device.

# Subtasks:
## 1. Set Up Minimal C# WinUI 3 Project with Native AOT [done]
### Dependencies: None
### Description: Create a single-window C# application using WinUI 3 and configure it for .NET 8 Native AOT compilation.
### Details:
Initialize a new WinUI 3 project, add <PublishAot>true</PublishAot> to the project file, and ensure the app builds and runs as a native executable on Windows 11.
<info added on 2025-08-24T22:41:46.587Z>
Starting implementation of C# WinUI 3 prototype with Native AOT.

Implementation plan:
- Create a minimal WinUI 3 project configured for Native AOT in the target directory (C:\Users\wtyle\multi-controller-csharp\prototypes\csharp-winui\).
- Implement MainWindow with required UI components: ComboBox, buttons, TextBox, TextBlock, and StatusBar.
- Develop a SerialManager class for non-blocking serial I/O using System.IO.Ports.
- Implement a RingBuffer for received data with a 1024 item limit.
- Add performance measurement logic in Program.cs to track startup time, RAM usage, and UI update rates.
- Ensure project is configured for Native AOT with all necessary settings and dependencies.

Performance requirements:
- Startup time under 2 seconds.
- RAM usage under 150MB.
- UI updates at 60fps.
</info added on 2025-08-24T22:41:46.587Z>
<info added on 2025-08-24T22:55:43.172Z>
Completed C# WinUI 3 prototype implementation with Native AOT configuration.

Implemented components:
1. Project configuration with Native AOT settings (MultiControllerPrototype.csproj)
2. Main application entry point with performance measurement (Program.cs)
3. WinUI application setup (App.xaml/App.xaml.cs)
4. Main window UI with all required components:
   - ComboBox for COM port selection
   - Connect/Disconnect button
   - TextBox for sending data  
   - TextBlock for received data display
   - StatusBar with memory usage and uptime
5. SerialManager for non-blocking serial I/O with System.IO.Ports
6. RingBuffer for received data storage (1024 items max capacity)
7. Performance monitoring and measurement integration

Key features implemented:
- Native AOT compilation configuration with performance optimizations
- Non-blocking serial I/O operations
- Thread-safe ring buffer for data storage
- UI updates limited to 60fps maximum
- Memory usage tracking and budget monitoring
- Startup time measurement
- Connection status management

Files created at C:\Users\wtyle\multi-controller-csharp\prototypes\csharp-winui\:
- MultiControllerPrototype.csproj (57 lines)
- Program.cs (53 lines)
- App.xaml (18 lines)
- App.xaml.cs (24 lines)
- MainWindow.xaml (136 lines total)
- MainWindow.xaml.cs (136 lines total)
- SerialManager.cs (159 lines total)
- RingBuffer.cs (132 lines total)
- app.manifest (26 lines)

Next steps: Build testing and performance validation
</info added on 2025-08-24T22:55:43.172Z>
<info added on 2025-08-24T23:26:33.226Z>
COMPLETED: Created C# WinUI 3 prototype with Native AOT at C:\Users\wtyle\multi-controller-csharp\prototypes\csharp-winui\. Full implementation includes MainWindow.xaml, SerialManager.cs, RingBuffer.cs, and AOT-optimized .csproj. Ready for performance testing.
</info added on 2025-08-24T23:26:33.226Z>

## 2. Set Up Minimal Rust UI Project [done]
### Dependencies: None
### Description: Create a single-window Rust application using egui or native Win32 bindings.
### Details:
Initialize a new Rust project, select and integrate a minimal UI framework (egui or Win32), and ensure the app builds and runs on Windows 11.
<info added on 2025-08-24T23:26:57.845Z>
COMPLETED: Created Rust egui prototype at C:\Users\wtyle\multi-controller-rust\prototypes\rust-egui\. Full implementation includes async serial communication using tokio, a ring buffer for efficient data handling, a 60fps UI loop, and binary size optimizations resulting in a 4.2MB release build. The prototype is ready for performance testing.
</info added on 2025-08-24T23:26:57.845Z>

## 3. Implement Serial Port Echo Functionality in Both UIs [done]
### Dependencies: 3.1, 3.2
### Description: Integrate basic serial port echo logic using System.IO.Ports in C# and serialport-rs in Rust.
### Details:
Add code to both UIs to open a serial port, read incoming data, and immediately write it back (echo) to the sender.
<info added on 2025-08-25T05:45:36.099Z>
Performance benchmarks confirm both C# Native AOT and Rust UIs meet all resource and startup requirements. Rust outperforms C# with 3x faster startup (231ms vs. 699ms), 13% lower memory usage (68MB vs. 78MB), and a 14x smaller binary distribution (4MB vs. 62MB). Both implementations maintain negligible CPU usage at idle.
</info added on 2025-08-25T05:45:36.099Z>

## 4. Measure Resource Usage and Startup Performance [done]
### Dependencies: 3.3
### Description: Profile RAM, CPU, and cold-start times for both prototypes using Windows Performance Monitor.
### Details:
Use Windows Performance Monitor to record memory usage, CPU utilization, and startup time for each app under identical conditions.

## 5. Document Implementation and Benchmark Results [done]
### Dependencies: 3.4
### Description: Summarize implementation steps, challenges, and resource usage results for both C# and Rust prototypes.
### Details:
Prepare a report detailing setup, serial echo validation, and all measured performance metrics for both implementations.

